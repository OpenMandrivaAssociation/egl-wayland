From ddaa27209a8149c1960c70799c87151206401bbc Mon Sep 17 00:00:00 2001
From: David Gow <david@ingeniumdigital.com>
Date: Mon, 4 Apr 2022 14:30:29 +0800
Subject: [PATCH] Defer resizes until next SwapBuffers

Applications which call wl_egl_window_resize() in the middle of a frame
from another thread will hang, as MakeCurrent() is called from the
wrong thread.

The obvious fix for this is to delay the resize until the next
eglSwapBuffers() call. An SDL-side implementation of this exists:
https://github.com/libsdl-org/SDL/pull/4821
But since some things should update immediately on resize (even if the
attached buffer doesn't), it seems better to have this in egl.

This patch fixes games such as:
- Imposter Factory:
https://store.steampowered.com/app/1182620/Impostor_Factory/
- Life is Strange:
https://store.steampowered.com/app/319630/Life_is_Strange__Episode_1/

Both would hang on startup if run against a wayland-enabled build of
SDL, but work perfectly with this patch.

Signed-off-by: David Gow <david@ingeniumdigital.com>
---
 include/wayland-eglsurface.h |  9 +++++++
 src/wayland-eglsurface.c     | 52 ++++++++++++++++++++++++------------
 src/wayland-eglswap.c        |  2 ++
 3 files changed, 46 insertions(+), 17 deletions(-)

diff --git a/include/wayland-eglsurface.h b/include/wayland-eglsurface.h
index c4f0d02..836f05a 100644
--- a/include/wayland-eglsurface.h
+++ b/include/wayland-eglsurface.h
@@ -128,11 +128,20 @@ typedef struct WlEglSurfaceRec {
      * before dispatching frame sync events in wlEglWaitFrameSync().
      */
     pthread_mutex_t mutexLock;
+
+    /* We want to delay the resizing of the window surface until the next
+     * eglSwapBuffers(), so just set a resize flag.
+     */
+    EGLBoolean isResized;
 } WlEglSurface;
 
 WL_EXPORT
 EGLBoolean wlEglInitializeSurfaceExport(WlEglSurface *surface);
 
+void wlEglResizeSurfaceIfRequired(WlEglDisplay *display,
+                                  WlEglPlatformData *pData,
+                                  WlEglSurface *surface);
+
 EGLSurface wlEglCreatePlatformWindowSurfaceHook(EGLDisplay dpy,
                                                 EGLConfig config,
                                                 void *nativeWin,
diff --git a/src/wayland-eglsurface.c b/src/wayland-eglsurface.c
index 78e1fa6..1af0d87 100644
--- a/src/wayland-eglsurface.c
+++ b/src/wayland-eglsurface.c
@@ -1555,37 +1555,25 @@ EGLBoolean wlEglInitializeSurfaceExport(WlEglSurface *surface)
     return EGL_TRUE;
 }
 
-static void
-resize_callback(struct wl_egl_window *window, void *data)
+void
+wlEglResizeSurfaceIfRequired(WlEglDisplay *display, WlEglPlatformData *pData, WlEglSurface *surface)
 {
-    WlEglDisplay      *display = NULL;
-    WlEglPlatformData *pData   = NULL;
-    WlEglSurface      *surface = (WlEglSurface *)data;
     EGLint             err     = EGL_SUCCESS;
 
-    if (!window || !surface) {
-        return;
-    }
-
-    display = surface->wlEglDpy;
-    if (!wlEglIsWaylandDisplay(display->nativeDpy) ||
-        !wlEglIsWaylandWindowValid(surface->wlEglWin)) {
+    if (!surface) {
         return;
     }
-    pData = display->data;
 
     pthread_mutex_lock(&surface->mutexLock);
 
     /* Resize stream only if window geometry has changed */
-    if ((surface->width != window->width) ||
-        (surface->height != window->height) ||
-        (surface->dx != window->dx) ||
-        (surface->dy != window->dy)) {
+    if (surface->isResized) {
         // If a damage thread is in use, wait for it to finish processing all
         //   pending frames
         finish_wl_eglstream_damage_thread(surface, &surface->ctx, 0);
 
         discard_surface_context(surface);
+        surface->isResized = EGL_FALSE;
         surface->ctx.wlStreamResource = NULL;
         surface->ctx.isAttached = EGL_FALSE;
         surface->ctx.eglSurface = EGL_NO_SURFACE;
@@ -1611,6 +1599,36 @@ resize_callback(struct wl_egl_window *window, void *data)
     pthread_mutex_unlock(&surface->mutexLock);
 }
 
+static void
+resize_callback(struct wl_egl_window *window, void *data)
+{
+    WlEglDisplay      *display = NULL;
+    WlEglSurface      *surface = (WlEglSurface *)data;
+
+    if (!window || !surface) {
+        return;
+    }
+
+    display = surface->wlEglDpy;
+    if (!wlEglIsWaylandDisplay(display->nativeDpy) ||
+        !wlEglIsWaylandWindowValid(surface->wlEglWin)) {
+        return;
+    }
+
+    pthread_mutex_lock(&surface->mutexLock);
+
+    /* Resize stream only if window geometry has changed */
+    if ((surface->width != window->width) ||
+        (surface->height != window->height) ||
+        (surface->dx != window->dx) ||
+        (surface->dy != window->dy)) {
+            surface->isResized = EGL_TRUE;
+            wl_surface_commit(surface->wlSurface);
+    }
+    
+    pthread_mutex_unlock(&surface->mutexLock);
+}
+
 static EGLBoolean validateSurfaceAttrib(EGLAttrib attrib, EGLAttrib value)
 {
     switch (attrib) {
diff --git a/src/wayland-eglswap.c b/src/wayland-eglswap.c
index 22d3267..113d753 100644
--- a/src/wayland-eglswap.c
+++ b/src/wayland-eglswap.c
@@ -64,6 +64,8 @@ EGLBoolean wlEglSwapBuffersWithDamageHook(EGLDisplay eglDisplay, EGLSurface eglS
 
     surface = eglSurface;
 
+    wlEglResizeSurfaceIfRequired(display, data, surface);
+
     if (surface->pendingSwapIntervalUpdate == EGL_TRUE) {
         /* Send request from client to override swapinterval value based on
          * server's swapinterval for overlay compositing
